package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"markly-backend/graph/model"
	"markly-backend/internal/middleware"
	"markly-backend/internal/models"
	"markly-backend/internal/utils"
	"strconv"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	// Validate input
	if err := utils.ValidateRegisterInput(input.Email, input.Username, input.Password); err != nil {
		return nil, err
	}
	
	// Sanitize input
	email := strings.ToLower(strings.TrimSpace(input.Email))
	username := utils.SanitizeString(input.Username)
	
	// Check if user already exists
	var existingUser models.User
	if err := r.DB.Where("email = ? OR username = ?", email, username).First(&existingUser).Error; err == nil {
		return nil, errors.New("user already exists with this email or username")
	}

	// Hash password
	hashedPassword, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, errors.New("failed to process password")
	}

	// Create user
	user := models.User{
		Email:    email,
		Username: username,
		Password: hashedPassword,
	}

	if err := r.DB.Create(&user).Error; err != nil {
		return nil, err
	}

	// Generate JWT token
	token, err := utils.GenerateJWT(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:        strconv.FormatUint(uint64(user.ID), 10),
			Email:     user.Email,
			Username:  user.Username,
			CreatedAt: user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// Validate input
	if err := utils.ValidateEmail(input.Email); err != nil {
		return nil, errors.New("invalid email format")
	}
	
	if input.Password == "" {
		return nil, errors.New("password is required")
	}
	
	// Sanitize email
	email := strings.ToLower(strings.TrimSpace(input.Email))
	
	// Find user by email
	var user models.User
	if err := r.DB.Where("email = ?", email).First(&user).Error; err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Check password
	if !utils.CheckPasswordHash(input.Password, user.Password) {
		return nil, errors.New("invalid credentials")
	}

	// Generate JWT token
	token, err := utils.GenerateJWT(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:        strconv.FormatUint(uint64(user.ID), 10),
			Email:     user.Email,
			Username:  user.Username,
			CreatedAt: user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		},
	}, nil
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, input model.CreateCollectionInput) (*model.Collection, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Validate input
	if err := utils.ValidateCollectionName(input.Name); err != nil {
		return nil, err
	}
	
	if err := utils.ValidateDescription(*input.Description); err != nil {
		return nil, err
	}
	
	if err := utils.ValidateColor(*input.Color); err != nil {
		return nil, err
	}
	
	// Sanitize input
	name := utils.SanitizeString(input.Name)
	description := utils.SanitizeString(*input.Description)
	
	// Create collection
	collection := models.Collection{
		Name:        name,
		Description: &description,
		Color:       input.Color,
		UserID:      userID,
	}

	if err := r.DB.Create(&collection).Error; err != nil {
		return nil, err
	}

	return &model.Collection{
		ID:          strconv.FormatUint(uint64(collection.ID), 10),
		Name:        collection.Name,
		Description: collection.Description,
		Color:       collection.Color,
		UserID:      strconv.FormatUint(uint64(collection.UserID), 10),
		CreatedAt:   collection.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:   collection.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// UpdateCollection is the resolver for the updateCollection field.
func (r *mutationResolver) UpdateCollection(ctx context.Context, id string, input model.UpdateCollectionInput) (*model.Collection, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Parse collection ID
	collectionID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid collection ID")
	}

	// Find collection
	var collection models.Collection
	if err := r.DB.Where("id = ? AND user_id = ?", collectionID, userID).First(&collection).Error; err != nil {
		return nil, errors.New("collection not found")
	}

	// Update fields
	if input.Name != nil {
		collection.Name = *input.Name
	}
	if input.Description != nil {
		collection.Description = input.Description
	}
	if input.Color != nil {
		collection.Color = input.Color
	}

	if err := r.DB.Save(&collection).Error; err != nil {
		return nil, err
	}

	return &model.Collection{
		ID:          strconv.FormatUint(uint64(collection.ID), 10),
		Name:        collection.Name,
		Description: collection.Description,
		Color:       collection.Color,
		UserID:      strconv.FormatUint(uint64(collection.UserID), 10),
		CreatedAt:   collection.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:   collection.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// DeleteCollection is the resolver for the deleteCollection field.
func (r *mutationResolver) DeleteCollection(ctx context.Context, id string) (bool, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return false, errors.New("user not authenticated")
	}

	// Parse collection ID
	collectionID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return false, errors.New("invalid collection ID")
	}

	// Delete collection (and associated bookmarks due to foreign key constraint)
	result := r.DB.Where("id = ? AND user_id = ?", collectionID, userID).Delete(&models.Collection{})
	if result.Error != nil {
		return false, result.Error
	}

	return result.RowsAffected > 0, nil
}

// CreateBookmark is the resolver for the createBookmark field.
func (r *mutationResolver) CreateBookmark(ctx context.Context, input model.CreateBookmarkInput) (*model.Bookmark, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Validate input
	if err := utils.ValidateTitle(input.Title); err != nil {
		return nil, err
	}
	
	if err := utils.ValidateURL(input.URL); err != nil {
		return nil, err
	}
	
	if input.Description != nil {
		if err := utils.ValidateDescription(*input.Description); err != nil {
			return nil, err
		}
	}
	
	if input.Notes != nil {
		if err := utils.ValidateNotes(*input.Notes); err != nil {
			return nil, err
		}
	}
	
	if input.Tags != nil {
		if err := utils.ValidateTags(*input.Tags); err != nil {
			return nil, err
		}
	}

	// Parse collection ID
	collectionID, err := strconv.ParseUint(input.CollectionID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid collection ID")
	}

	// Verify collection belongs to user
	var collection models.Collection
	if err := r.DB.Where("id = ? AND user_id = ?", collectionID, userID).First(&collection).Error; err != nil {
		return nil, errors.New("collection not found")
	}

	// Sanitize input
	title := utils.SanitizeString(input.Title)
	url := strings.TrimSpace(input.URL)
	
	var description *string
	if input.Description != nil {
		sanitized := utils.SanitizeString(*input.Description)
		description = &sanitized
	}
	
	var notes *string
	if input.Notes != nil {
		sanitized := utils.SanitizeString(*input.Notes)
		notes = &sanitized
	}
	
	var tags []string
	if input.Tags != nil {
		tags = utils.SanitizeTags(*input.Tags)
	}

	// Create bookmark
	bookmark := models.Bookmark{
		Title:        title,
		URL:          url,
		Description:  description,
		Notes:        notes,
		Tags:         tags,
		CollectionID: uint(collectionID),
		UserID:       userID,
	}

	if err := r.DB.Create(&bookmark).Error; err != nil {
		return nil, err
	}

	// Capture images asynchronously (non-blocking)
	go func() {
		if r.ImageCaptureService != nil {
			result := r.ImageCaptureService.CaptureImages(input.URL)
			
			// Update bookmark with captured images
			updateData := map[string]interface{}{}
			if result.FaviconURL != nil {
				updateData["favicon"] = *result.FaviconURL
			}
			if result.ScreenshotURL != nil {
				updateData["screenshot"] = *result.ScreenshotURL
			}
			
			if len(updateData) > 0 {
				r.DB.Model(&bookmark).Updates(updateData)
			}
		}
	}()

	return &model.Bookmark{
		ID:           strconv.FormatUint(uint64(bookmark.ID), 10),
		Title:        bookmark.Title,
		URL:          bookmark.URL,
		Description:  bookmark.Description,
		Notes:        bookmark.Notes,
		Favicon:      bookmark.Favicon,
		Screenshot:   bookmark.Screenshot,
		Tags:         bookmark.Tags,
		CollectionID: strconv.FormatUint(uint64(bookmark.CollectionID), 10),
		UserID:       strconv.FormatUint(uint64(bookmark.UserID), 10),
		CreatedAt:    bookmark.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:    bookmark.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// UpdateBookmark is the resolver for the updateBookmark field.
func (r *mutationResolver) UpdateBookmark(ctx context.Context, id string, input model.UpdateBookmarkInput) (*model.Bookmark, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Parse bookmark ID
	bookmarkID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid bookmark ID")
	}

	// Find bookmark
	var bookmark models.Bookmark
	if err := r.DB.Where("id = ? AND user_id = ?", bookmarkID, userID).First(&bookmark).Error; err != nil {
		return nil, errors.New("bookmark not found")
	}

	// Update fields
	if input.Title != nil {
		bookmark.Title = *input.Title
	}
	if input.URL != nil {
		bookmark.URL = *input.URL
	}
	if input.Description != nil {
		bookmark.Description = input.Description
	}
	if input.Notes != nil {
		bookmark.Notes = input.Notes
	}
	if input.Tags != nil {
		bookmark.Tags = input.Tags
	}
	if input.CollectionID != nil {
		collectionID, err := strconv.ParseUint(*input.CollectionID, 10, 64)
		if err != nil {
			return nil, errors.New("invalid collection ID")
		}
		// Verify collection belongs to user
		var collection models.Collection
		if err := r.DB.Where("id = ? AND user_id = ?", collectionID, userID).First(&collection).Error; err != nil {
			return nil, errors.New("collection not found")
		}
		bookmark.CollectionID = uint(collectionID)
	}

	if err := r.DB.Save(&bookmark).Error; err != nil {
		return nil, err
	}

	return &model.Bookmark{
		ID:           strconv.FormatUint(uint64(bookmark.ID), 10),
		Title:        bookmark.Title,
		URL:          bookmark.URL,
		Description:  bookmark.Description,
		Notes:        bookmark.Notes,
		Favicon:      bookmark.Favicon,
		Screenshot:   bookmark.Screenshot,
		Tags:         bookmark.Tags,
		CollectionID: strconv.FormatUint(uint64(bookmark.CollectionID), 10),
		UserID:       strconv.FormatUint(uint64(bookmark.UserID), 10),
		CreatedAt:    bookmark.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:    bookmark.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// DeleteBookmark is the resolver for the deleteBookmark field.
func (r *mutationResolver) DeleteBookmark(ctx context.Context, id string) (bool, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return false, errors.New("user not authenticated")
	}

	// Parse bookmark ID
	bookmarkID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return false, errors.New("invalid bookmark ID")
	}

	// Delete bookmark
	result := r.DB.Where("id = ? AND user_id = ?", bookmarkID, userID).Delete(&models.Bookmark{})
	if result.Error != nil {
		return false, result.Error
	}

	return result.RowsAffected > 0, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Find user
	var user models.User
	if err := r.DB.First(&user, userID).Error; err != nil {
		return nil, errors.New("user not found")
	}

	return &model.User{
		ID:        strconv.FormatUint(uint64(user.ID), 10),
		Email:     user.Email,
		Username:  user.Username,
		CreatedAt: user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt: user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// Collections is the resolver for the collections field.
func (r *queryResolver) Collections(ctx context.Context) ([]*model.Collection, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Find collections
	var collections []models.Collection
	if err := r.DB.Where("user_id = ?", userID).Find(&collections).Error; err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	var result []*model.Collection
	for _, collection := range collections {
		result = append(result, &model.Collection{
			ID:          strconv.FormatUint(uint64(collection.ID), 10),
			Name:        collection.Name,
			Description: collection.Description,
			Color:       collection.Color,
			UserID:      strconv.FormatUint(uint64(collection.UserID), 10),
			CreatedAt:   collection.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:   collection.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		})
	}

	return result, nil
}

// Collection is the resolver for the collection field.
func (r *queryResolver) Collection(ctx context.Context, id string) (*model.Collection, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Parse collection ID
	collectionID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid collection ID")
	}

	// Find collection
	var collection models.Collection
	if err := r.DB.Where("id = ? AND user_id = ?", collectionID, userID).First(&collection).Error; err != nil {
		return nil, errors.New("collection not found")
	}

	return &model.Collection{
		ID:          strconv.FormatUint(uint64(collection.ID), 10),
		Name:        collection.Name,
		Description: collection.Description,
		Color:       collection.Color,
		UserID:      strconv.FormatUint(uint64(collection.UserID), 10),
		CreatedAt:   collection.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:   collection.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// Bookmarks is the resolver for the bookmarks field.
func (r *queryResolver) Bookmarks(ctx context.Context, filter *model.BookmarkFilter, limit *int, offset *int) ([]*model.Bookmark, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Build query
	query := r.DB.Where("user_id = ?", userID)

	// Apply filters
	if filter != nil {
		if filter.Search != nil {
			searchTerm := "%" + *filter.Search + "%"
			query = query.Where("title LIKE ? OR description LIKE ? OR notes LIKE ?", searchTerm, searchTerm, searchTerm)
		}
		if filter.CollectionID != nil {
			collectionID, err := strconv.ParseUint(*filter.CollectionID, 10, 64)
			if err != nil {
				return nil, errors.New("invalid collection ID")
			}
			query = query.Where("collection_id = ?", collectionID)
		}
		if filter.Tags != nil && len(filter.Tags) > 0 {
			// Search for bookmarks that contain any of the specified tags
			for _, tag := range filter.Tags {
				query = query.Where("JSON_CONTAINS(tags, ?)", fmt.Sprintf("\"%s\"", tag))
			}
		}
	}

	// Apply pagination
	if limit != nil {
		query = query.Limit(*limit)
	}
	if offset != nil {
		query = query.Offset(*offset)
	}

	// Find bookmarks
	var bookmarks []models.Bookmark
	if err := query.Find(&bookmarks).Error; err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	var result []*model.Bookmark
	for _, bookmark := range bookmarks {
		result = append(result, &model.Bookmark{
			ID:           strconv.FormatUint(uint64(bookmark.ID), 10),
			Title:        bookmark.Title,
			URL:          bookmark.URL,
			Description:  bookmark.Description,
			Notes:        bookmark.Notes,
			Favicon:      bookmark.Favicon,
			Screenshot:   bookmark.Screenshot,
			Tags:         bookmark.Tags,
			CollectionID: strconv.FormatUint(uint64(bookmark.CollectionID), 10),
			UserID:       strconv.FormatUint(uint64(bookmark.UserID), 10),
			CreatedAt:    bookmark.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:    bookmark.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		})
	}

	return result, nil
}

// Bookmark is the resolver for the bookmark field.
func (r *queryResolver) Bookmark(ctx context.Context, id string) (*model.Bookmark, error) {
	// Get user from context
	userID, ok := ctx.Value(middleware.UserIDKey).(uint)
	if !ok {
		return nil, errors.New("user not authenticated")
	}

	// Parse bookmark ID
	bookmarkID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid bookmark ID")
	}

	// Find bookmark
	var bookmark models.Bookmark
	if err := r.DB.Where("id = ? AND user_id = ?", bookmarkID, userID).First(&bookmark).Error; err != nil {
		return nil, errors.New("bookmark not found")
	}

	return &model.Bookmark{
		ID:           strconv.FormatUint(uint64(bookmark.ID), 10),
		Title:        bookmark.Title,
		URL:          bookmark.URL,
		Description:  bookmark.Description,
		Notes:        bookmark.Notes,
		Favicon:      bookmark.Favicon,
		Screenshot:   bookmark.Screenshot,
		Tags:         bookmark.Tags,
		CollectionID: strconv.FormatUint(uint64(bookmark.CollectionID), 10),
		UserID:       strconv.FormatUint(uint64(bookmark.UserID), 10),
		CreatedAt:    bookmark.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:    bookmark.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
